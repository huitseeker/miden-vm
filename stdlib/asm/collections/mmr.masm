#! Computes the `ilog2(number)` and `2^(ilog2(number))`.
#!
#! number must be non-zero, otherwise this will error
#!
#! Stack transition:
#! Cycles:  12 + 9 * leading_zeros
#! Input: [number, ...]
#! Output: [ilog2, power_of_two, ...]
export.ilog2_checked
  # prepare the stack (2 cycles)
  push.2147483648 # power_of_two from high to low bit
  push.0          # bit_pos from the most-signficant, `31-bit_pos` equals to ilog2
  # stack: [bit_pos, power_of_two, number, ...]

  dup.1 dup.3 u32checked_and eq.0 # (4 cycles)

  # find the first most-significant true bit (9 * leading_zero cycles)
  while.true
    add.1 swap div.2 swap  # (5 cycles)
    dup.1 dup.3 u32checked_and eq.0 # (4 cycles)
  end

  # compute ilog2 (4 cycles)
  push.31 swap sub
  # stack: [ilog2, power_of_two, number, ...]

  # drop number (2 cycles)
  movup.2 drop
  # stack: [ilog2, power_of_two, ...]
end

#! Loads the leaf at the absolute `pos` in the MMR.
#!
#! This MMR implementation supports only u32 positions.
#!
#! Stack transition:
#! Cycles: 60 + 9 * tree_position (where `tree_position` is 0-indexed bit position from most to least significant)
#! Input: [pos, mmr_ptr, ...]
#! Output: [N, R, ...] where `N` is the leaf and `R` is the MMR peak that owns the leaf.
export.get
  # load the num_leaves of the MMR (2 cycles)
  dup.1 mem_load
  # stack: [num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves & pos`, this contains all peaks before `pos` (and maybe some after the owning peak) (3 cycles)
  dup.1 dup.1 u32checked_and
  # stack: [before_candidates, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves - before_candidates`, this removes every peak before the owner (result may include peaks after owner) (4 cycles)
  dup.1 swap sub
  # stack: [owner_candidates, num_leaves, pos, mmr_ptr, ...]

  # compute `ilog2(owner_candidates)` and `2**depth`, it corresponds to the owner peak and its depth (13 + 9 * leading_zeros cycles)
  exec.ilog2_checked swap
  # stack: [owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `owner_peak - 1`, this mask corresponds to every peak after the owner (3 cycles)
  dup.0 sub.1
  # stack: [after_mask, owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves & after_mask`, uses the mask to compute the actual after peaks (2 cycles)
  dup.3 u32checked_and
  # stack: [after_peaks, owner_peak, depth, num_leaves, pos, mmr_ptr, ...]

  # compute `num_leaves - (after_peaks + owner_peak)`, this computes the before peaks (5 cycles)
  add movup.2 swap sub
  # stack: [peaks_before, depth, pos, mmr_ptr, ...]

  # compute `pos - peaks_before`, this computes the relative_pos of the leaf w.r.t. the owner peak. (4 cycles)
  movup.2 dup.1 sub
  # stack: [relative_pos, peaks_before, depth, mmr_ptr, ...]

  # compute `popcount(peaks_before)`, the count peaks before the target to be skipped when loading from mem (2 cycles)
  swap u32checked_popcnt
  # stack: [peak_count, relative_pos, depth, mmr_ptr, ...]

  # compute `mmr_ptr + peak_count + 1` the target tree index (3 cycles)
  movup.3 add add.1
  # stack: [mmr_ptr, relative_pos, depth, ...]

  # load the target peak (6 cycles)
  padw movup.4 mem_loadw
  # stack: [P, relative_pos, depth, ...]

  # find the tree depth (2 cycles)
  movup.4 movup.5
  # stack: [depth, relative_pos, P, ...]

  # corner case, leaf values are not supported in the VM's Merkle store, so the
  # `mtree_get` instruction will fail for the single leaf case of the MMR. (2 cycles)
  dup.0 eq.0
  if.true
     drop drop dupw # (6 cycles)
     # stack: [leaf, root, ...]
  else
     # verify and get the leaf (9 cycles)
      mtree_get
     # stack: [leaf, root, ...]
  end
end
